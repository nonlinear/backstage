---
name: backstage
description: "Manage backstage workflow in projects (ROADMAP, checks/, CHANGELOG). Triggers: 'backstage start', 'vamos trabalhar no X', 'backstage health'. Installs protocol if missing, updates global rules, runs health checks, shows active epics. Use for: epic planning, project setup, quality enforcement, context switching."
type: public
version: 1.0.0
status: production
author: nonlinear
license: MIT
requires:
  - https://github.com/nonlinear/backstage
dependencies:
  - bash
  - awk
  - sed
  - git
---

# Backstage Skill

**Nickname:** `backstage:`

**Objective:** Universal project status management for AI-assisted development. Ensures documentation matches reality before every commit.

---

## üî¥ Why This Skill Exists (Anti-Drift)

**Backstage-skill = ANTI-DRIFT:**
- ‚úÖ Force context awareness (project/epic)
- ‚úÖ Health checks prevent chaos
- ‚úÖ Architecture-first workflow
- ‚úÖ Roadmap visibility = no surprises

**WITHOUT IT:**  
Work happens outside backstage ‚Üí drift ‚Üí broken trust ‚Üí triple metabolic cost

**WITH IT:**  
"good morning X" ‚Üí automatic context load ‚Üí work inside boundaries ‚Üí paridade maintained

---

**The Metabolic Cost Problem:**

Without backstage, delegation costs **triple**:
1. The work itself
2. Explicating methodology (ethics, preferences, protocols)
3. Defining WHERE that learning gets stored (VISION? SOUL? SKILL? memory?)

This is **exhausting** for the human.

**Investment is worth it ONLY IF plateau is reached:**
- Human teaches ONCE ‚Üí AI internalizes
- Each session: READ context files ‚Üí act according to ethics
- Each session: LESS explanation needed
- Plateau = Human delegates, AI executes without supervision

**This skill enforces stabilization.**  
Force context awareness (project/epic/design architecture) to prevent drift.  
**3x work becomes 1x work.**

---

## Policies & Checks Enforcement

**Backstage-skill enforces ALL rules in checks/ (deterministic + interpretive, global + local).**

### Enforcement Model

```mermaid
flowchart TD
    READ_CHK["Read checks/<br/>global + local<br/>[Deterministic .sh + Interpretive .md]"]
    
    CONFLICT{Conflict?}
    MERGE[Merge compatible rules]
    LOCAL[Local wins]
    
    AI["AI interprets .md checks<br/>[Contextual enforcement]"]
    SH["Bash executes .sh checks<br/>[Deterministic validation]"]
    
    AI_ACT[‚úÖ Enforce or discuss]
    AI_AMBIG[‚ö†Ô∏è Ask user]
    
    SH_OK[‚úÖ All checks pass]
    SH_FAIL[‚ùå Checks failed]
    
    REPORT["Report:<br/>üìã Interpretive (always ‚úÖ)<br/>üîç Deterministic (‚úÖ/‚ùå)"]
    
    READ_CHK --> CONFLICT
    CONFLICT -->|No| MERGE
    CONFLICT -->|Yes| LOCAL
    MERGE --> AI
    MERGE --> SH
    LOCAL --> AI
    LOCAL --> SH
    
    AI -->|Clear| AI_ACT
    AI -->|Ambiguous| AI_AMBIG
    
    SH -->|Pass| SH_OK
    SH -->|Fail| SH_FAIL
    
    AI_ACT --> REPORT
    AI_AMBIG --> REPORT
    SH_OK --> REPORT
    SH_FAIL --> REPORT
```

**Two enforcement domains:**

1. **Policies (Interpretive)**
   - `policies/global/*.md` = Universal workflow rules
   - `policies/local/*.md` = Project-specific overrides
   - **Enforced by:** AI (reads markdown, interprets context, acts)
   - **Always pass:** AI reads, understands, will act accordingly

2. **Checks (Deterministic)**
   - `checks/global/*.sh` = Universal validation tests
   - `checks/local/*.sh` = Project-specific tests
   - **Enforced by:** Bash (executes shell scripts, exit codes)
   - **Pass or fail:** ‚úÖ (exit 0) or ‚ùå (exit non-zero)

**Polycentric governance:**
- Global + local rules coexist
- Local wins on conflict
- AI merges when compatible

**Report format:**

```
üìã Policies (interpretive):
  ‚úÖ policies/global/branch-workflow.md (read)
  ‚úÖ policies/global/commit-style.md (read)
  ‚úÖ policies/local/dogfooding.md (read)

üîç Checks (deterministic):
  ‚úÖ checks/global/navigation-block-readme.sh
  ‚úÖ checks/global/semver-changelog.sh
  ‚ùå checks/local/pre-merge-tasks.sh (incomplete tasks)
```

**Self-contained:** All prompts in SKILL.md (no external prompt files needed).

---

## Mermaid Diagram Generation (Interpretive)

**Purpose:** Automatically generate + propagate ROADMAP diagram to all backstage files.

**Workflow:**

1. **Parse ROADMAP.md** (deterministic - SH):
   ```bash
   parse-roadmap.sh backstage/ROADMAP.md
   # Output: version|status_emoji|name
   ```

2. **Read policies/ diagram rules** (interpretive - AI):
   - `policies/global/navigation-block.md` defines default format (linear graph, all epics, sequential)
   - `policies/local/*.md` can override (gantt, flowchart, or `diagram: none`)
   - Local wins on conflict

3. **Generate mermaid** (interpretive - AI):
   - Apply policies/ rules to parsed data
   - Create mermaid syntax matching specification
   - Example (default):
     ```mermaid
     graph LR
         A[üèóÔ∏è v0.1.0 Active Epic] --> B[üìã v0.2.0 Backlog Epic]
     ```

4. **Propagate to all files** (deterministic - SH):
   - Insert after `> ü§ñ` marker
   - README.md, ROADMAP.md, CHANGELOG.md
   - Remove old diagrams (anti-drift)

**AI Prompt (when running backstage-start/end):**

> Read policies/global/navigation-block.md and policies/local/*.md for diagram rules.
> Run `parse-roadmap.sh` to extract epics.
> Generate mermaid diagram following policies/ rules (prefer local over global).
> Insert diagram after navigation block (`> ü§ñ`) in all backstage files.
> If local policies say `diagram: none`, skip generation.

**Tools:**
- `parse-roadmap.sh` - Extract version|status|name from ROADMAP.md
- `policies/` - Diagram format rules (type, include/exclude logic, status mapping)

---

## Polycentric Governance (How It Works)

```mermaid
flowchart TD
    GLOBAL_POL[policies/global/*.md<br/>Universal rules]
    LOCAL_POL[policies/local/*.md<br/>Project-specific overrides]
    
    GLOBAL_CHK[checks/global/*.sh<br/>Universal tests]
    LOCAL_CHK[checks/local/*.sh<br/>Project-specific tests]
    
    AI[AI reads policies/]
    BASH[Bash executes checks/]
    CONFLICT{Conflict?}
    
    GLOBAL_POL --> AI
    LOCAL_POL --> AI
    GLOBAL_CHK --> BASH
    LOCAL_CHK --> BASH
    
    AI --> CONFLICT
    CONFLICT -->|Yes| LOCAL_POL
    CONFLICT -->|No| MERGE[Merge rules]
    
    MERGE --> ACTION[Execute workflow]
    LOCAL_POL --> ACTION
    BASH --> ACTION
```

**This skill enforces polycentric governance:**
- Reads ALL `policies/**/*.md` files (global + local)
- Executes ALL `checks/**/*.sh` files (global + local)
- Merges policies when compatible
- Prefers local policies on conflict
- Reports deterministic check results (pass/fail)

**Triggered by:** "good morning", "good night", "backstage start/end"

---

## Workflow Diagram

```mermaid
flowchart TD
    START["Trigger 1Ô∏è‚É£<br/>[SH]"]
    MODE{"Session mode?"}
    
    %% Common enforcement module
    READ_POL["Read policies/<br/>global + local<br/>[AI interprets MD]"]
    EXEC_CHK["Execute checks/<br/>global + local<br/>[Bash runs SH]"]
    
    REPORT["Report 6Ô∏è‚É£<br/>üìã Policies (‚úÖ)<br/>üîç Checks (‚úÖ/‚ùå)"]
    CHECKS_GATE{"All checks<br/>passed?"}
    
    %% Start Branch
    START_BRANCH["Read README ü§ñ block 2Ô∏è‚É£<br/>[MD ‚Üí AI]"]
    START_FILES["Locate status files 3Ô∏è‚É£<br/>[SH]"]
    START_GIT["Check git branch 4Ô∏è‚É£<br/>[SH]"]
    START_WORK["Analyze changes 5Ô∏è‚É£<br/>[SH]"]
    START_FIX["üõë STOP: Fix issues<br/>[AI + SH]"]
    START_UPDATE["Update docs 7Ô∏è‚É£<br/>[SH writes MD]"]
    START_REPORT["Developer context 8Ô∏è‚É£<br/>[AI reads MD]"]
    START_PUSH["Push / Groom 9Ô∏è‚É£<br/>[SH]"]
    
    %% End Branch
    END_FIXES["Add fixes to roadmap<br/>[AI writes MD]"]
    END_PUSH["Commit + push<br/>[SH]"]
    END_VICTORY["Victory lap üèÜ<br/>[AI reads MD]"]
    END_BODY["Body check ‚è∏Ô∏è<br/>[AI prompt]"]
    END_CLOSE["Close VS Code üåô<br/>[SH]"]
    END_SILENT["[STAY SILENT]"]
    
    %% Flow
    START --> MODE
    
    MODE -->|Start| START_BRANCH
    START_BRANCH --> START_FILES
    START_FILES --> START_GIT
    START_GIT --> START_WORK
    START_WORK --> READ_POL
    START_WORK --> EXEC_CHK
    
    READ_POL --> REPORT
    EXEC_CHK --> REPORT
    REPORT --> CHECKS_GATE
    
    CHECKS_GATE -->|No, start mode| START_FIX
    START_FIX --> READ_POL
    CHECKS_GATE -->|Yes| START_UPDATE
    START_UPDATE --> START_REPORT
    START_REPORT --> START_PUSH
    
    MODE -->|End| READ_POL
    MODE -->|End| EXEC_CHK
    CHECKS_GATE -->|No, end mode| END_FIXES
    CHECKS_GATE -->|Yes| END_PUSH
    END_FIXES --> END_VICTORY
    END_PUSH --> END_VICTORY
    END_VICTORY --> END_BODY
    END_BODY --> END_CLOSE
    END_CLOSE --> END_SILENT
```

**Domain labels:**
- **[MD]** - Markdown file (policies/*.md, ROADMAP.md) = Human/AI prompts
- **[SH]** - Shell script (checks/*.sh, backstage-start.sh) = Machine executables
- **[AI reads MD]** - AI parses markdown, understands rules/prompts
- **[AI writes MD]** - AI generates markdown content
- **[SH writes MD]** - Script modifies markdown files (checkboxes, navigation blocks)
- **[Bash runs SH]** - Bash executes shell scripts (deterministic validation)
- **[AI interprets MD]** - AI reads policies/, acts contextually

**Critical separation:**
- **policies/ = prompts** - AI reads, interprets, acts
- **checks/ = executors** - Bash runs commands, returns exit codes
- **AI intermediates** - Reads policies/, executes checks/, integrates report

**Notes:**

**1Ô∏è‚É£ Trigger:** "backstage start", "vamos trabalhar no X", "whatsup" (start mode) OR "backstage end", "boa noite", "wrap up" (end mode)
- **Code:** `backstage-start.sh` OR `backstage-end.sh`

**2Ô∏è‚É£ Read README ü§ñ block:** Find navigation block between `> ü§ñ` markers. Extract all status file paths (ROADMAP, CHANGELOG, policies/, checks/). This is ONLY source of truth for file locations.
- **Code:** `backstage-start.sh::read_navigation_block()`

**3Ô∏è‚É£ Locate status files:** Use paths from ü§ñ block. If missing, STOP and ask user where to create them. Check BOTH global (`backstage/policies/global/`, `backstage/checks/global/`) and local (`backstage/policies/local/`, `backstage/checks/local/`) for polycentric governance.
- **Code:** `backstage-start.sh::locate_status_files()`

**4Ô∏è‚É£ Check git branch:** Run `git branch --show-current`. Determine work context.
- **Code:** `backstage-start.sh::check_branch()`

**5Ô∏è‚É£ Analyze changes:** 
```bash
git diff --name-status
git diff --stat
LAST_VERSION=$(grep -m1 "^## v" CHANGELOG.md | cut -d' ' -f2)
git log --oneline "${LAST_VERSION}..HEAD"
```
Categorize: patch/minor/major. Compare with ROADMAP. Match reality to plans.
- **Code:** `backstage-start.sh::analyze_changes()`

**6Ô∏è‚É£ Report - Policies + Checks:**

**Report format:**
```
üìã Policies (interpretive):
  ‚úÖ policies/global/branch-workflow.md (read)
  ‚úÖ policies/global/commit-style.md (read)
  ‚úÖ policies/local/dogfooding.md (read)

üîç Checks (deterministic):
  ‚úÖ checks/global/navigation-block-readme.sh
  ‚úÖ checks/global/semver-changelog.sh
  ‚ùå checks/local/pre-merge-tasks.sh (incomplete tasks)
```

**Policies always ‚úÖ:** AI reads, interprets, will act accordingly

**Checks can fail ‚ùå:** Exit code determines status

**Mode behavior:**
- **Start mode:** Hard fail (block commit if checks fail)
- **End mode:** Soft fail (warn, add to ROADMAP)

- **Code:** `backstage-start.sh::report_enforcement()`

**7Ô∏è‚É£ Update docs:** If checks pass, auto-update ROADMAP (mark checkboxes) and CHANGELOG (add new entries at TOP, append-only). Bump version. Add navigation menu to all status files.
- **Code:** `backstage-start.sh::update_docs()`

**8Ô∏è‚É£ Developer context:** Generate outcome-based summary (5 possible states: üõë Failed, ‚ö†Ô∏è Mismatch, üßë Grooming, ‚úÖ Progress, üéâ Complete). Show: When, What, Why, Status, Next.
- **Code:** `backstage-start.sh::show_developer_context()`

**9Ô∏è‚É£ Push / Groom:** If checks passed, commit with appropriate message (progress/release). If grooming mode, just update ROADMAP priorities.
- **Code:** `backstage-start.sh::prompt_push()`

**Victory lap üèÜ:** Brief reminder of achievements (3 main items max + stats). Keep it short.
- **Code:** `backstage-end.sh::victory_lap()`

**Body check ‚è∏Ô∏è:** Ask: Hungry? Thirsty? Tired? Need to stretch? What does body NEED right now?
- **Code:** `backstage-end.sh::body_check()`

**Close VS Code üåô:** Run countdown + `osascript -e 'quit app "Visual Studio Code"'`. CRITICAL: Agent must NOT send ANY message after this or VS Code will prompt "unsaved changes".
- **Code:** `backstage-end.sh::close_vscode()`

**[STAY SILENT]:** No reply after closing VS Code (prevents unsaved prompt).

---

## When to Use

**Trigger patterns:**

**Start mode:**
- "backstage start"
- "whatsup"
- "vamos trabalhar no X"
- "what's the status"
- Before every commit (especially after long breaks)

**End mode:**
- "backstage end"
- "boa noite"
- "wrap up"
- "pause work"
- End of work session, when tired, or context-switch

---

## Key Principles

1. **README's ü§ñ block = Single source of truth** for file locations
2. **Status files = AI prompts** (checks/ = tests, policies/ = rules, ROADMAP = backlog, CHANGELOG = history)
3. **Polycentric governance** (global + local rules, local wins on conflict)
4. **Checks must pass** before commit (non-negotiable for start mode, soft fail for end mode)
5. **CHANGELOG is append-only** (never edit old entries, add NEW entry for corrections)
6. **5 possible outcomes** (Failed, Mismatch, Grooming, Progress, Complete)
7. **Documentation auto-syncs** with reality (mark checkboxes, bump versions, move epics)
8. **Body check at end** (mental health + momentum preservation)
9. **Silent after VS Code close** (prevent unsaved prompt)
10. **Works on ANY project** (no hardcoded paths, reads README first)

---

## The 5 States (Start Mode)

| State               | When         | Action            | Can Push? |
|---------------------|--------------|-------------------|-----------|
| üõë Failed Checks    | Tests fail   | Fix issues        | ‚ùå NO     |
| ‚ö†Ô∏è Docs Mismatch    | Code ‚â† docs  | Auto-update docs  | ‚úÖ YES    |
| üßë Grooming         | No changes   | Plan next work    | N/A       |
| ‚úÖ In Progress      | Partial work | Update checkboxes | ‚úÖ YES    |
| üéâ Version Complete | All done!    | Move to CHANGELOG | ‚úÖ YES üéâ |

---

## Check Policy

**From checks/:**

- **Epic branches:** Soft fail (warn but allow)
- **Main branch:** Hard fail (block merge)
- **Wrap-up (end mode):** Soft fail (list fixes, don't push)

---

## The 3-Level System

**Level 1: Personal** (not tracked)
- Your books, notes, local config
- Not part of any project

**Level 2: Project-Specific** (e.g., Librarian MCP)
- Generic tool others can use
- Has status files (ROADMAP, CHANGELOG, checks/, policies/)
- Example flagship project for Level 3

**Level 3: Meta-Workflow** (this skill)
- Works for ANY project
- No hardcoded paths
- Reads README to find everything
- Can be copied anywhere

---

## Reference Prompts

**Original prompts (for future refinement):**
- `backstage-start.prompt.md` - Full start workflow specification
- `backstage-close.prompt.md` - Full end workflow specification

**Location:** `/Users/nfrota/Documents/nonlinear/.github/prompts/`

**Note:** This SKILL.md is a DRAFT distillation of those prompts. Future refinements will improve diagram, add emoji notes, clarify steps. The original prompts contain ALL details.

---

## TODO / Future Refinements

- [ ] **Update .sh scripts** to read policies/ and checks/ folders
- [ ] **Add emoji notes** (like design-discrepancy 1Ô∏è‚É£-8Ô∏è‚É£ format)
- [ ] **Simplify diagram** (consolidated enforcement, removed "separate" step)
- [ ] **Add code execution points** (where scripts run, if any)
- [ ] **Create templates** (for new projects without status files)
- [ ] **Document edge cases** (no git, no README, corrupted files)
- [ ] **Add examples** (successful runs, failed runs, grooming sessions)
- [ ] **Test on multiple projects** (validate universal workflow)
- [ ] **Consider splitting** (start vs end as separate skills?)

---

**Created:** 2026-02-12
**Updated:** 2026-02-18 (v1.0.0 - modular policies/checks)
**Status:** Documentation updated, scripts pending
**Location:** `~/Documents/backstage/skills/backstage/SKILL.md`
